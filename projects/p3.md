---
title: Project 3
layout: page
parent: Projects
nav_order: 3
---

# Project 3: RIX
{: .no_toc }
Due at 10:29 AM on February 24
{: .fs-6 .fw-300 }

<img src="../assets/logos/rix-ros-logo-transparent.png" alt="Node Topic List" width="25%" />

## Getting the Starter Code
Navigate to the directory where you would like to store the code for this project. Run the following commands to install the project starter code or download it manually [here](https://www.dropbox.com/scl/fi/a3d5fe2chidenmgme828x/p2_stencil.tar.gz?rlkey=nfxtwihl3h5jp4fq4cw6irndz&st=3j857342&dl=0).
```bash
wget "https://www.dropbox.com/scl/fi/a3d5fe2chidenmgme828x/p2_stencil.tar.gz?rlkey=nfxtwihl3h5jp4fq4cw6irndz&st=3j857342&dl=0" -O p2.tar.gz
tar -xf p2.tar.gz
rm p2.tar.gz
```

It is *strongly* recommended to use GitHub to track the changes made to your project. First, create a new **private** repository in GitHub. Then, navigate to the project directory and run the following commands.
```bash
git init
git commit -m "first commit"
git branch -M main
git remote add origin [LINK TO REPO]
git push -u origin main
```
This will establish a main branch on the remote repository and add the starter code as the first commit.

## Learning Objectives
1. Implement a centralized, topic-based, loosely-coupled, publish-subscribe system using TCP sockets
2. Understand the architecture of robot programs as a graph of nodes connected by topics
3. Understand how a robot operating system is a layer of abstraction above a regular operating system

## Overview
### Robot Operating System Semantics
The following was adapted from the [official ROS documentation](http://wiki.ros.org).

A node is a process that performs computation. Nodes are combined together into a graph and communicate with one another using topics. Topics are named buses over which nodes exchange messages. Topics have anonymous publish/subscribe semantics, meaning nodes can operate independently, without direct dependencies on each other. In general, nodes are not aware of who they are communicating with. Instead, nodes that are interested in data subscribe to the relevant topic; nodes that generate data publish to the relevant topic. There can be multiple publishers and subscribers to a topic.

Nodes are meant to operate at a fine-grained scale; a robotic system will usually comprise many nodes. Below is a graph for the system that you will implement in this project.

<img src="../assets/images/project/p3-fig-1.svg" alt="Node Topic List" width="75%" />

<img src="../assets/images/project/p3-fig-2.svg" alt="Node Topic Graph" width="75%" />

The use of nodes provides several benefits to the overall system. There is fault tolerance as crashes are isolated to individual nodes, code complexity is reduced in comparison to monolithic systems, implementation details are well hidden as the nodes expose a minimal API to the rest of the graph, and alternate implementations, even in other programming languages, can easily be substituted.

In a loosely-coupled system, a node needs the ability to discover other nodes that are publishing on or subscribed to its relevent topics. You will implement a centralized system to handle node discovery. In ROS, this is called the Master ([see why this naming convention is outdated](https://www.nytimes.com/2021/04/13/technology/racist-computer-engineering-terms-ietf.html)). This central process provides naming and registration services to the rest of the nodes in the system, maintaining a ledger mapping publishers and subscribers to topics. It enables individual nodes to locate one another. Once these nodes have located each other they communicate with each other peer-to-peer.

### RIX Libraries
This project depends on four libraries: `rix-util`, `rix-ipc`, `rix-msg`, and `mbot-msgs`. These precompiled libraries are in the starter code with their associated headers. 

1. **`rix/util`**
  - Signal handling
  - Command line argument parsing
  - Timing libraries to control loop frequency
  - Logging library for organized, concurrent command line output
2. **`rix/ipc`**
  - TCP socket interfaces (from Project 2)
3. **`rix/msg`**
  - Message struct definitions and serialization functions

## 3.1.1 Node Implementation (1 Point)
### TODO
- **`rix/include/rix/core/node.hpp`**
  - Implement `advertise` and `subscribe` functions in `Node` class.
  - Declare container for storing publishers and subscribers.
- **`rix/src/core/node.cpp`**
  - Implement the `Node` class.

## 3.1.2 Publisher Implementation (1.5 Points)
### TODO
- **`rix/include/rix/core/publisher/`**
  - **`pub_impl_base.hpp`**
    - Declare container types.
  - **`pub_impl_tcp.hpp`**
    - Declare containers for networking.
  - **`publisher.hpp`**
    - Implement `Publisher::publish` function.
- **`rix/src/rix/core/publisher`**
  - **`pub_impl_base.cpp`**
    - Implement `PubImplBase` class.
  - **`pub_impl_tcp.cpp`**
    - Implement `PubImplTCP` class.
  - **`publisher.cpp`**
    - Implement `Publisher` class.

## 3.1.3 Subscriber Implementation (1.5 Points)
### TODO
- **`rix/include/rix/core/`**
  - **`sub_impl_base.hpp`**
    - Declare container types.
  - **`sub_impl_tcp.hpp`**
    - Declare containers for networking.
  - **`subscriber_callback.hpp`**
    - Implement `SubscriberCallback<TMsg>::call` function.
- **`rix/src/rix/core/`**
  - **`sub_impl_base.cpp`**
    - Implement the `SubImplBase` class.
  - **`sub_impl_tcp.cpp`**
    - Implement the `SubImplTCP` class.
  - **`subscriber.cpp`**
    - Implement the `Subscriber` class.

Feature 1 requires you to implement the node, publisher, and susbcriber systems as described in the overview.

Each publisher and subscriber contains a `ComponentInfo` struct that you will need to fill with the necessary information in the constructors. The `ComponentInfo` and `MessageInfo` structs are shown below. `ComponentInfo` and `MessageInfo` belong to the namespace `rix::msg::component`, as you will see when you look at the `include/rix/msg` header files.

```cpp
struct ComponentInfo {
    component::MessageInfo message_info[3];
    uint64_t node_id;
    uint64_t component_id;
    uint64_t machine_id;
    uint8_t protocol;
    char topic[32];
}
```

- The `message_info` field is an array of `MessageInfo` structs. These structs provide information about the type of messages that the publisher or subscriber expect to use.
- The `node_id` field is a 'unique' ID for each node.
- The `component_id` field is a 'unique' ID for each publisher and susbcriber.
- The `machine_id` field is a 'unique' ID for every machine that installs RIX.
- The `protocol` field is a byte that describes the implementation being used (in our case it will always be TCP: 0x01).
- The `topic` field is a char array that contains the name of the relevant topic for the publisher or subscriber.

(Note: we say 'unique' because there is no way to ensure true uniqueness among the IDs we will use in this project. There should be a low likelihood that the IDs collide i.e. we can use random numbers)

```cpp
struct MessageInfo {
    uint64_t hash_upper;
    uint64_t hash_lower;
    uint32_t length;
}
```

- The `hash_upper` field is the upper 64 bits of a truly unique message ID.
- The `hash_lower` field is the lower 64 bits of a truly unique message ID.
- The `length` field is the size of the message in bytes.

(Note: these hashes are truly unique because they are calculated using an [MD5 Hash](https://en.wikipedia.org/wiki/MD5) over the message definition file, which produces a 128-bit value from a sequence of characters. Each message has an `info` method that can be used to obtain the `MessageInfo` struct for that message type. These methods can be found in the message header files in `include/rix/msg/`.)

Each publisher and subscriber will also have a contact ID used for discoevry. This is important because subscribers need to know the URI of the publisher that they will be connecting to. Additionally, both subscribers and publishers need to order their clients/connections according to some ID so that they know which to modify upon disconnection. The `ID` struct is shown below with the `URI` struct.
```cpp
struct ID {
    uint64_t component_id;
    component::URI uri;
}
```

- The `component_id` field is a 'unique' ID for each publisher and susbcriber (the same as above).
- The `uri` field is the resource identifier that will enable network communication.

```cpp
struct URI {
    uint16_t port;
    char address[16];
}
```

- The `port` field is the port being used by the `Client` or `Server`.
- The `address` field is the IP address of the `Client` or `Server`.

All messages to and from the mediator are `Info` messages, which contain a `ComponentInfo` and an `ID` message along with some metadata including an `error` and `opcode` field.
```cpp
struct standard::Info {
    standard::ComponentInfo component_info;
    standard::ID contact_id;
    uint8_t opcode;
    uint8_t error;
}
```

If the message is sent by the mediator:
- The `component_info` field contains information about the relevant publisher or subscriber contained by the node receiving the message.
- The `contact_id` field contains information about which publisher or subscriber is attempting to connect/disconnect

If the message is sent by a node:
- The `component_info` field contains information about the publisher or subscriber that is registering/deregistering with the mediator.
- The `contact_id` field contains the information necessary for a separate publisher or subscriber to connect to the relevent publisher or subscriber.

- The `opcode` field determines that type of operation that will occur based on this message. These opcodes are contained by the enum `OPCODE` in `rix/include/rix/core/common`. A subset of these opcodes are shown below (these are the only ones necessary for this project):
```cpp
enum OPCODE {
    SUB_REGISTER = 80,
    PUB_REGISTER,
    SUB_NOTIFY = 90,
    PUB_NOTIFY,
    SUB_DEREGISTER = 100,
    PUB_DEREGISTER,
    SUB_DISCONNECT = 110,
    PUB_DISCONNECT,
    SUB_REQUEST = 120,
    SUB_RESPONSE,
    PUB_RESPONSE = 130,
    MED_TERMINATE = 160
};
```
- The `error` field is a byte that represents whether or not an error has occurred. For the purposes of this project, assume that if the `error` field is nonzero, then an error has occured. The value of this error does not matter.

The inheritance hierarchy used by publishers and subscribers in this project is modeled directly after the ROS implementations, which specify a non-templated wrapper class (`Publisher` and `Susbcriber`) that contain pointers to implementation classes. The `Publisher` and `Subscriber` classes provide a high-level description of how a subsriber and publisher ought to discover and connect to each other. The `PubImplBase` and `SubImplBase` generate a scalable architecture for implementing this high-level description. `PubImplTCP` and `SubImplTCP` are derived from the `PubImplBase` and `SubImplBase` classes respectively, and represent a single type of implementation (TCP) for this publish-subscribe system. Many are possible, including shared memory, UDP multicast, and WebSockets. You will only have to implement TCP in this project.

## 3.2 Mediator Implementation (3 Points)
### TODO
- **`rixhub/include/mediator.hpp`**
  - Declare containers to store TCP connections and nodes.
- **`rixhub/include/ledger.hpp`**
  - Declare a container to store information about the registered components.
  - Declare a container to store information about the active topics.
- **`rixhub/src/mediator.cpp`**
  - Implement the `Mediator` class.
- **`rixhub/src/ledger.cpp`**
  - Implement the `Ledger` class.
- **`rixhub/src/main.cpp`**
  - Implement the main executable for `rixhub`.

Feature 2 requires you to implement the central process responsible for node discovery. You will implement the `Mediator` class, which will handle messages from nodes. The `Mediator` class uses the `Ledger` class to track the topics, publishers, and subscribers relevent to each `Node`.

## 3.3.1 Talker Node (0.5 Point)
### TODO
- **`src/talker.hpp`**
  - Implement the `talker` executable.

## 3.3.2 Listener Node (0.5 Point)
### TODO
- **`src/listener.hpp`**
  - Implement the `listener` executable.

Component 3 requires you to implement a simple listener/talker example. This is modeled after the ROS tutorial [Writing a Simple Publisher and Subscriber (C++)](http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29). Take a look at the tutorial before implementing the programs to see the similarities/differences between the ROS and RIX APIs. The ROS tutorial will use the `std_msgs::String` message type. We require you to use the RIX `rix::msg::standard::Header` message type found in `include/rix/msg/standard/Header.hpp`. More detailed instructions can be found in the project starter code.

## 3.4 Lidar Driver Node (1 Point)
### TODO
- **`lidar_driver/src/main.cpp`**
  - Implement the `LidarDriver` class.
  - Implement the `main` function.

Implement a node that publishes `rix::msg::mbot::LidarScan` messages on the topic `lidar_scan`.

## 3.5 MBot Driver Node (1 Point)
### TODO
- **`mbot_driver/src/main.cpp`**
  - Implement the `MBotDriver` class.
  - Implement the `main` function.

The MBot driver node will communicate on several topics. They are shown in the tables below.

**Subscribers**

| Topic | Message Type |
|-------|--------------|
| motor_pwm_cmd  | `rix::mbot::MotorPWM`      |
| motor_vel_cmd  | `rix::mbot::MotorVelocity` |
| robot_vel_cmd  | `rix::mbot::Twist2D`       |
| odometry_reset | `rix::mbot::Pose2D`        |
| encoders_reset | `rix::mbot::Encoders`      |
| timesync       | `rix::mbot::Timestamp`     |

**Publishers**

| Topic | Message Type |
|-------|--------------|
| odometry_reset | `rix::mbot::Pose2D`        |
| encoders_reset | `rix::mbot::Encoders`      |
| imu            | `rix::mbot::IMU`           |
| motor_pwm      | `rix::mbot::MotorPWM`      |
| motor_velocity | `rix::mbot::MotorVelocity` |
| robot_velocity | `rix::mbot::Twist2D`       |

In the MBot Driver, you are responsible for wrapping the `MBot` class as a node, using `MBot::set_callback` to publish information on the relevant topic and `MBot::send_message` within the subscriber callbacks to send the relevant message over USB to the MBot.

## Building
**TODO** Need to update once CAEN is figured out.

To compile the entire project, run the following commands. The `build` directory will not exist by default, you must create it first.
```bash
cd build
cmake ..
make
```

If you would like to build separate parts of the project individually, add the executable name after `make`. For example:
```bash
cd build
cmake ..
make [rixhub | lidar_driver | mbot_driver | talker | listener]
```
This is especially useful if you have not implemented other parts of the project and want to test what you have implemented.

We understand that this project is much larger in scope compared to the previous two projects. With that in mind, we have provided some executables in the `bin` folder of the starter code, including `rixhub`, `slam`, `timesync`, and `teleop-keyboard`. These executables were compiled with the solution code and provided for you to help test and debug your implementation of RIX.

You can use the solution binary of rixhub to test your implementations of `Node`, `Publisher`, and `Subscriber`. To run the `rixhub` executable, enter the following command.
```bash
./bin/rixhub
```

You can use the other executables to debug your implementations of `lidar_driver`, `mbot_driver`, and `rixhub`. You can add the `-h` flag to toggle to help message to display the command line arguments that the executables need.
```bash
./bin/[slam | timesync | teleop-keyboard] [-h]
```

## Grading and Submission
Below is the grading outline for Project 2.

| Feature                          | Points |
|----------------------------------|--------|
| Node Implementation              | 1      |
| Publisher Implementation	       | 1.5    |
| Subscriber Implementation	       | 1.5    |
| Mediator Implementation          | 3      |
| Talker Node                      | 0.5    |
| Listener Node                    | 0.5    |
| Lidar Driver Node                | 1      |
| MBot Driver Node                 | 1      |

Submit the necessary files to the [ROB 320 Autograder](http://autograder.io).